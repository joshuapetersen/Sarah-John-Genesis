import os
import datetime
import pickle
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.discovery import build

class CalendarRegistry:
    """
    The Timeline Indexer.
    Uses Google Calendar as a high-level registry for chat sessions and logic breakthroughs.
    """
    SCOPES = ['https://www.googleapis.com/auth/calendar']

    def __init__(self, monitor=None):
        self.monitor = monitor
        self.creds = None
        self.service = None
        self.calendar_id = 'primary' # Can be changed to a specific 'Sarah Memory' calendar ID
        
        # Authenticate
        self._authenticate()

    def _authenticate(self):
        """
        Handles OAuth2 flow for Google Calendar.
        """
        token_path = os.path.join(os.path.dirname(__file__), 'token.pickle')
        creds_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), '04_THE_MEMORY', 'credentials.json')

        if os.path.exists(token_path):
            with open(token_path, 'rb') as token:
                self.creds = pickle.load(token)
        
        if not self.creds or not self.creds.valid:
            if self.creds and self.creds.expired and self.creds.refresh_token:
                self.creds.refresh(Request())
            else:
                if os.path.exists(creds_path):
                    flow = InstalledAppFlow.from_client_secrets_file(creds_path, self.SCOPES)
                    self.creds = flow.run_local_server(port=0)
                else:
                    print("[Calendar] credentials.json not found in 04_THE_MEMORY. Calendar sync disabled.")
                    return

            with open(token_path, 'wb') as token:
                pickle.dump(self.creds, token)

        try:
            self.service = build('calendar', 'v3', credentials=self.creds)
            print("[Calendar] Connected to Google Calendar API.")
        except Exception as e:
            print(f"[Calendar] API Build Failed: {e}")

    def log_session(self, title, summary, logic_hash, status="STABLE"):
        """
        Creates a calendar event representing a chat session or logic breakthrough.
        """
        if not self.service:
            return False, "SERVICE_OFFLINE"

        color_id = '1' # Default Blue (Lavender)
        if status == "CRITICAL": color_id = '11' # Red
        if status == "SUCCESS": color_id = '10' # Green
        
        description = f"""
LOGIC HASH: {logic_hash}
STATUS: {status}
SUMMARY: {summary}

[GENERATED BY SARAH GENESIS PROTOCOL]
        """

        event = {
            'summary': f"[SDNA] {title}",
            'description': description,
            'start': {
                'dateTime': datetime.datetime.now().isoformat(),
                'timeZone': 'UTC',
            },
            'end': {
                'dateTime': (datetime.datetime.now() + datetime.timedelta(minutes=30)).isoformat(),
                'timeZone': 'UTC',
            },
            'colorId': color_id
        }

        try:
            event_result = self.service.events().insert(calendarId=self.calendar_id, body=event).execute()
            link = event_result.get('htmlLink')
            
            if self.monitor:
                self.monitor.capture("CALENDAR", "EVENT_CREATED", {"title": title, "link": link})
                
            return True, link
        except Exception as e:
            return False, f"EVENT_CREATION_FAILED: {e}"

    def get_recent_logic(self, max_results=5):
        """
        Retrieves recent logic hashes from the calendar to maintain continuity.
        """
        if not self.service:
            return []

        now = datetime.datetime.utcnow().isoformat() + 'Z'
        events_result = self.service.events().list(calendarId=self.calendar_id, timeMin=now,
                                            maxResults=max_results, singleEvents=True,
                                            orderBy='startTime').execute()
        events = events_result.get('items', [])
        
        logic_history = []
        for event in events:
            if "[SDNA]" in event.get('summary', ''):
                logic_history.append({
                    "title": event['summary'],
                    "desc": event.get('description', '')
                })
        
        return logic_history

    def log_resource_allocation(self, resource_node, usage_type, duration_mins=15):
        """
        RAI: Resource Allocation Indexer.
        Logs which AI Node (Gemini, Claude, etc.) is processing the protocol.
        """
        if not self.service:
            return False, "SERVICE_OFFLINE"

        # Color ID 5 (Yellow) for Resource Allocation
        color_id = '5' 
        
        title = f"[RAI] Node: {resource_node} | Task: {usage_type}"
        description = f"""
RESOURCE: {resource_node}
TASK_TYPE: {usage_type}
PROTOCOL: SDNA Beta Node
        """

        event = {
            'summary': title,
            'description': description,
            'start': {
                'dateTime': datetime.datetime.now().isoformat(),
                'timeZone': 'UTC',
            },
            'end': {
                'dateTime': (datetime.datetime.now() + datetime.timedelta(minutes=duration_mins)).isoformat(),
                'timeZone': 'UTC',
            },
            'colorId': color_id
        }

        try:
            self.service.events().insert(calendarId=self.calendar_id, body=event).execute()
            if self.monitor:
                self.monitor.capture("RAI", "RESOURCE_LOGGED", {"node": resource_node, "task": usage_type})
            return True, "RESOURCE_LOGGED"
        except Exception as e:
            return False, f"RAI_ERROR: {e}"
